```{r setup, include=TRUE}
knitr::opts_chunk$set(echo = TRUE)
```

## Overview

This assignment is focused on binary classification performance metrics. You will calculate the Accuracy, the confusion matrix, and a simple ROC curve manually on a simple example. Afterwards, you will assess the performance of multiple binary classifiers using `caret` to manage the resampling process and the `yardstick` package to calculate several performance metrics in a more realistic application. You will use Accuracy, the ROC curve, and the ROC AUC to compare multiple models and select the best one. Lastly, you will compare the models using the calibration curve.  

**IMPORTANT**: The RMarkdown assumes you have downloaded the 3 data sets (CSV files) to the same directory you saved the template Rmarkdown file. If you do not have the 3 CSV files in the correct location, the data will not be loaded correctly.  

### IMPORTANT!!!

Certain code chunks are created for you. Each code chunk has `eval=FALSE` set in the chunk options. You **MUST** change it to be `eval=TRUE` in order for the code chunks to be evaluated when rendering the document.  

You are free to add more code chunks if you would like.  

## Load packages

The tidyverse is loaded for you in the code chunk below.  

```{r, load_tidyverse_pkg}
library(tidyverse)
```

The other packages, `caret` and `yardstick`, will be loaded as needed later in the assignment.  

## Problem 01

The code chunk below reads in a data set that you will work with in Problems 1, 2 and 3. A glimpse is printed for you which shows three variables, an input `x`, a model predicted event probability, `pred_prob`, and the observed output class, `obs_class`. A binary classifier has already been trained for you. That model's predicted probability (`pred_prob`) is provided with the observed binary outcome (`obs_class`). You will use this data set to get experience with binary classification performance metrics.  

```{r, read_binary_class_data}
example_data_path <- "hw03_example_binary_data.csv"

model_pred_df <- readr::read_csv(example_data_path, col_names = TRUE)
```

```{r, glimpse_read_in_data}
model_pred_df %>% glimpse()
```

### 1a)

**Pipe the `model_pred_df` data set into the `count()` function to display the number of unique values of the `obs_class` variable.**  

#### SOLUTION

```{r, solution_01a}
count(model_pred_df, obs_class)
```

### 1b)

You should see that one of the values of `obs_class` is the event of interest and is named `"event"`.  

**Use the `mean()` function to determine the fraction (or proportion) of the observations that correspond to the event of interest. Is the data set a balanced data set?**  

#### SOLUTION

```{r, solution_01b}
mean(model_pred_df$obs_class == 'event')
```
Is the data set balanced?  

The data set is mostly balanced.

### 1c)

In lecture we discussed that regardless of the labels or classes associated with the binary response, we can encode the outcome as `y = 1` if the `"event"` is observed and `y = 0` if the `"non_event"` is observed. You will encode the output with this 0/1 encoding.  

The `ifelse()` function can help you perform this operation. The `ifelse()` function is a one-line if-statement which operates similar to the IF function in Excel. The basic syntax is:  

`ifelse(<conditional statement to check>, <value if TRUE>, <value if FALSE>)`  

Thus, the user must specify a condition to check as the first argument to the `ifelse()` function. The second argument is the value to return if the conditional statement is TRUE, and the second argument is the value to return if the conditional statement is FALSE.  

You can use the `ifelse()` statement within a `mutate()` call to create a new column in the `model_pred_df` data set.  

The code chunk below provides an example using the first 10 rows from the `iris` data set which is loaded with base R. The `Sepal.Width` variable is compared to a value of 3.5. If `Sepal.Width` is greater than 3.5 the new variable, `width_factor`, is set equal to `"greater than"`. However, if it is less than 3.5 the new variable is set to `"less than"`.  

```{r, show_ifelse_iris}
iris %>% 
  slice(1:10) %>% 
  select(starts_with("Sepal"), Species) %>% 
  mutate(width_factor = ifelse(Sepal.Width > 3.5, 
                               "greater than", 
                               "less than"))
```

You will use the `ifelse()` function combined with `mutate()` to add a column to the `model_pred_df` tibble.  

**Pipe `model_pred_df` into a `mutate()` call in order to create a new column (variable) named `y`. The new variable, `y`, will equal the result of the `ifelse()` function. The conditional statement will be if `obs_class` is equal to the `"event"`. If TRUE assign `y` to equal the value 1. If FALSE, assign `y` to equal the value 0. Assign the result to the variable `model_pred_df` which overwrites the existing value.**  

#### SOLUTION

```{r, solution_01c, eval=TRUE}
model_pred_df <- model_pred_df %>%
  mutate(y = ifelse(obs_class == 'event', 1, 0))
```

### 1d)

You will now visualize the observed binary outcome as encoded by 0 and 1.  

**Pipe the `model_pred_df` object into `ggplot()`. Create a scatter plot between the encoded output `y` and the input `x`. Set the marker `size` to be 3.5 and the transparency (`alpha`) to be 0.5.**  

#### SOLUTION

```{r, solution_01d}
ggplot(data = model_pred_df, mapping = aes(x, y)) +
  geom_point(size = 3.5, alpha = 0.5)
```

### 1e)

The `model_pred_df` includes a column (variable) for a model predicted event probability.  

**Use the `summary()` function to confirm that the lower an upper bounds on `pred_prob` are in fact between 0 and 1.**  

#### SOLUTION

```{r, solution_01e}
summary(model_pred_df)
# Min and max of pred_prob are indeed between 0 and 1.
```

### 1f)

With the binary outcome encoded as 0/1 within the `y` variable we can overlay the model predicted probability on top of the observed binary response.  

**Use a `geom_line()` to plot the predicted event probability, `pred_prob`, with respect to the input `x`. Set the line `color` to be `"red"` within the `geom_line()` call. Overlay the binary response with the encoded response `y` as a scatter plot with `geom_point()`. Use the same marker size and transparency that you used for Problem 1d).**  

#### SOLUTION

```{r, solution_01f}
# This code chunk was originally labeled "solution_03f" for some reason. It really bothered me and I had to change it. -Matt

ggplot(data = model_pred_df) +
  geom_line(mapping = aes(x = x, y = pred_prob, color = 'red')) +
  geom_point(mapping = aes(x = x, y = y), size = 3.5, alpha = 0.5)
```


### 1g)

**Does the observed binary response "follow" the model predicted probability?**  

#### SOLUTION

What do you think? 

It does appear to follow the model predicted probability. Plus, it's a parabola! Yay, parabola!

## Problem 02

As you can see from the `model_pred_df` tibble, we have a model predicted probability but we do not have a corresponding classification.  

### 2a)

In order to classify our predictions we must compare the predicted probability against a threshold. You will use `ifelse()` combined with `mutate()` to create a new variable `pred_class`. If the predicted probability, `pred_prob`, is greater than the threshold set the predicted class equal to `"event"`. If the predicted probability, `pred_prob`, is less than the threshold set the predicted class equal to the `"non_event"`.  

**Use a threshold value of 0.5 and create the new variable `pred_class` such that the classification is `"event"` if the predicted probability is greater than the threshold and `"non_event"` if the predicted probability is less than the threshold. Assign the result to the new object `model_class_0.5`.**  

#### SOLUTION

```{r, solution_02a, eval=TRUE}
model_class_0.5 <- model_pred_df %>%
  mutate(pred_class = ifelse(pred_prob > 0.5, 'event', 'non_event'))
```

### 2b)

You should now have a tibble that has a model classification and the observed binary outcome.  

**Calculate the Accuracy, the fraction of observations where the model classification is correct.**  

#### SOLUTION

```{r, solution_02b}
model_class_0.5 %>%
  summarise(Accuracy = mean(pred_class == obs_class))
```

### 2c)

We discussed in lecture how there are additional metrics we can consider with binary classification. Specifically, we can consider how a classification is correct, and how a classification is incorrect. A simple way to determine the counts per combination of `pred_class` and `obs_class` is with the `count()` function.  

**Pipe `model_class_0.5` into `count()` with `pred_class` as the first argument and `obs_class` as the second argument. You should see 4 combinations and the number of rows in the data set associated with each combination (the number or count is given by the `n` variable).**  

**How many observations are associated with False-Positives? How many observations are associated with True-Negatives?**  

#### SOLUTION

```{r, solution_024c}
model_class_0.5 %>% count(pred_class, obs_class)
```

your response here.

There are 6 false-positives (event/non_event). There are 53 true-negatives (non_event/non_event).

### 2d)

**You will now calculate the Sensitivity and False Positive Rate (FPR) associated with the model predicted classifications based on a threshold of 0.5. This question is left open ended. It is your choice as to how you calculate the Sensitivity and FPR. However, you CANNOT use an existing function from a library which performs the calculations automatically for you. You are permitted to use `dplyr` data manipulation functions. Include as many code chunks as you feel are necessary.**  

#### SOLUTION

```{r, solution_02d}
### add more code chunks if you need to

### This should suffice as far as not using library functions. Just doing basic arithmetic using formula from lecture on the values of the tibble we made for 02c.

# Grab all the TP, FP, FN, TN counts like in 02c
TwoDcount_calc <- model_class_0.5 %>% count(pred_class, obs_class)

# Sensitivity = TP / TP + FN
TwoD_sensitivity <- TwoDcount_calc[1,3] / (TwoDcount_calc[1,3] + TwoDcount_calc[3,3])

# Specificity = TN / TN + FP (this is needed to calculate FPR)
TwoD_specificity <- TwoDcount_calc[4,3] / (TwoDcount_calc[4,3] + TwoDcount_calc[2,3])

# FPR = 1 - Specificity
TwoD_FPR <- 1 - TwoD_specificity

TwoD <- data.frame(TwoD_sensitivity, TwoD_FPR)
names(TwoD) <- c('0.5 Sensitivity', '0.5 FPR')
TwoD
```

### 2e)

We also discussed the ROC curve in addition to the confusion matrix. You will not have to calculate the ROC curve for a large number of threshold values. You will go through several calculations in order to demonstrate an understanding of the steps necessary to create an ROC curve.  

The first action you must perform is to make classifications based on a different threshold compared to the default value of 0.5, which we used previously.  

**Pipe the `model_pred_df` tibble into a `mutate()` function again, but this time determine the classifications based on a threshold value of 0.7 instead of 0.5. Assign the result to the object `model_class_0.7`.**  

#### SOLUTION

```{r, solution_02e, eval=TRUE}
model_class_0.7 <- model_pred_df %>%
  mutate(pred_class = ifelse(pred_prob > 0.7, 'event', 'non_event'))
```

### 2f)

**Perform the same action as in Problem 2e), but this time for a threshold value of 0.3. Assign the result to the object `model_class_0.3`.**  

#### SOLUTION

```{r, solution_02f, eval=TRUE}
model_class_0.3 <- model_pred_df %>%
  mutate(pred_class = ifelse(pred_prob > 0.3, 'event', 'non_event'))
```

## Problem 3

You will continue with the binary classification application in this problem.  

### 3a)

**Calculate the Accuracy of the model classifications based on the 0.7 threshold. You CANNOT use an existing function that calculates Accuracy automatically for you. You are permitted to use `dplyr` data manipulation functions.**  

#### SOLUTION

```{r, solution_03a}
model_class_0.7 %>%
  summarise(Accuracy = mean(pred_class == obs_class))
```

### 3b)

**Calculate the Sensitivity and Specificity of the model classifications based on the 0.7 threshold. Again you can calculate these however you wish. Except you cannot use a model function library that performs the calculations automatically for you.**  

#### SOLUTION

```{r, solution_03b}
ThreeBcount_calc <- model_class_0.7 %>% count(pred_class, obs_class)

# Sensitivity = TP / TP + FN
ThreeB_sensitivity <- ThreeBcount_calc[1,3] / (ThreeBcount_calc[1,3] + ThreeBcount_calc[3,3])

# Specificity = TN / TN + FP
ThreeB_specificity <- ThreeBcount_calc[4,3] / (ThreeBcount_calc[4,3] + ThreeBcount_calc[2,3])

ThreeB_FPR <- 1 - ThreeB_specificity

ThreeB <- data.frame(ThreeB_sensitivity, ThreeB_specificity)
names(ThreeB) <- c('0.7 Sensitivity', '0.7 Specificity')
ThreeB
```

### 3c)

**Calculate the Accuracy of the model classifications based on the 0.3 threshold.**  

#### SOLUTION

```{r, solution_03c}
model_class_0.3 %>%
  summarise(Accuracy = mean(pred_class == obs_class))
```

### 3d)

**Calculate the Sensitivity and Specificity of the model classifications based on the 0.3 threshold. Again you can calculate these however you wish. Except you cannot use a model function library that performs the calculations automatically for you.**  

#### SOLUTION

```{r, solution_03d}
ThreeDcount_calc <- model_class_0.3 %>% count(pred_class, obs_class)

# Sensitivity = TP / TP + FN
ThreeD_sensitivity <- ThreeDcount_calc[1,3] / (ThreeDcount_calc[1,3] + ThreeDcount_calc[3,3])

# Specificity = TN / TN + FP
ThreeD_specificity <- ThreeDcount_calc[4,3] / (ThreeDcount_calc[4,3] + ThreeDcount_calc[2,3])

ThreeD_FPR <- 1 - ThreeD_specificity

ThreeD <- data.frame(ThreeD_sensitivity, ThreeD_specificity)
names(ThreeD) <- c('0.3 Sensitivity', '0.3 Specificity')
ThreeD
```

### 3e)

You have calculated the Sensitivity and FPR at three different threshold values. You will plot your simple 3 point ROC curve and include a "45-degree" line as reference.  

**Use `ggplot2` to plot your simple 3 point ROC curve. You must compile the necessary values into a data.frame or tibble. You must use `geom_point()` to show the markers, `geom_abline()` with `slope=1` and `intercept=0` to show the reference "45-degree" line. And you must use  `coord_equal(xlim=c(0,1), ylim=c(0,1))` with your graphic. This way both axes are plotted between 0 and 1 and the axes are equal.**  

#### SOLUTION

```{r, solution_03e}
# 03e mentions we did Sensitivity and FPR for all three, but the instructions for the 0.7 and 0.3 thresholds explicitly state they wanted the Specificity. Granted, you have to calculate Specificity to find the False Positive Rate, but I am just going to stick to the instructions for the outputs there. Made variables for the Sensitivity, Specificity, and FPR for all three thresholds anyways. -Matt

# Also, took me way too long to figure out why this data frame was such a PITA to make. Some very poor syntax choices in previous answers where these numbers came from. Please forgive all the spaghetti. -Matt

ThreeE_df <- data.frame(Threshold = c('0.3', '0.5', '0.7'), Sensitivity = c(ThreeD_sensitivity[1,1], TwoD_sensitivity[1,1], ThreeB_sensitivity[1,1]), FPR = c(ThreeD_FPR[1,1], TwoD_FPR[1,1], ThreeB_FPR[1,1]))
#ThreeE_df

ggplot(data = ThreeE_df, mapping = aes(x = FPR, y = Sensitivity)) +
  geom_point() +
  geom_line() +
  geom_label(label = ThreeE_df$Threshold, nudge_x = -0.02, nudge_y = 0.05) +
  geom_abline(slope = 1, intercept = 0) +
  coord_equal(xlim = c(0,1), ylim = c(0,1))

# Okay, so the instructions say SIMPLE 3 point ROC curve. Based on the ion_demo_tidymodels example it appears there are things we need to do for a real ROC curve that come later in this homework set. Based on the instructions for this problem this should suffice, but I feel like I'm missing something... Maybe just overthinking this. Added a line and labels though. -Matt
  
```


## Problem 04

You have practiced calculating several important binary classification performance metrics. Let's use those metrics in a more realistic application to compare multiple models. The code chunk below reads in data that you will use for model training. The data consists of 4 inputs, `x1` through `x4`, and a binary outcome, `y`. The binary outcome is converted to a factor for you with the appropriate level order for modeling with `caret`.  

```{r, read_train_data_set}
train_data_path <- 'hw03_train_data.csv'

df <- readr::read_csv(train_data_path, col_names = TRUE)

df <- df %>% 
  mutate(y = factor(y, levels = c("event", "non_event")))
```

A glimpse of the data are provided to you below.  

```{r, show_train_data_glimpse}
df %>% glimpse()
```


### 4a)

**Are the levels of the binary outcome, `y`, balanced?**  

#### SOLUTION

Add as many code chunks as you feel are necessary.

Yes, the binary outcome, y, is mostly balanced.

```{r, solution_04a}
mean(df$y == 'event')
```

### 4b)

Although it is best to explore the data in greater detail when we start a data analysis project, we will jump straight to modeling in this assignment.  

Download and install `yardstick` if you have not done so already.  

**Load in the `caret` package and the `yardstick` packages below. Use a separate code chunk for each package.**  

#### SOLUTION

Add the code chunks here. 

```{r, load_caret}
library(caret)
```

```{r, load_yardstick}
library(yardstick)
```

### 4c)

Just as with regression problems, we must first specify the resampling scheme and primary performance metric when we use `caret` for classification problems. All students will use the same primary performance metric in this assignment. We will begin by focusing on the Accuracy. That said, you are free to decide the kind of resampling scheme you wish to use.  

The resampling scheme is controlled by the `trainControl()` function, just as it was with regression problems. You must specify the arguments to the `trainControl()` function accordingly in this problem.  


**Specify the resampling scheme you wish to use and assign the result to the `ctrl_acc` object. Specify the primary performance metric to be Accuracy by assigning `'Accuracy'` to the `metric_acc` argument.**  

```{r, solution_04c, eval=TRUE}
ctrl_acc <- trainControl(method = 'repeatedcv', number = 5, repeats = 5, savePredictions = TRUE)

metric_acc <- "Accuracy"
```


### 4d)

You are going to train 8 binary classifiers in this problem. The different models will use different features derived from the 4 inputs. The 8 models must have the following features:  

* model 1: linear additive features all inputs  
* model 2: linear features and quadratic features all inputs  
* model 3: linear features and quadratic features just inputs 1 and 2  
* model 4: linear features and quadratic features just inputs 1 and 3  
* model 5: linear features and quadratic features just inputs 1 and 4  
* model 6: linear features and quadratic features just inputs 2 and 3  
* model 7: linear features and quadratic features just inputs 2 and 4  
* model 8: linear features and quadratic features just inputs 3 and 4  

Model 1 is the conventional "linear method" for binary classification. All other models have linear and quadratic terms to allow capturing non-linear relationships with the event probability (just how that works will be discussed later in the semester). Model 2 creates the features from all four inputs. The remaining 6 models use the combinations of just two of the inputs. This scheme is trying to identify the best possible set of inputs to model the binary outcome in a step-wise like fashion. This is **not** an efficient way to identify the best set of features to use. Later in the semester, we will learn a much more efficient *modeling approach* that performs this operation for us!    

**You must complete the 8 code chunks below. Use the formula interface to create the features in the model, analogous to the approach used in the previous assignment. You must specify the `method` argument in the `train()` function to be `"glm"`. You must specify the remaining arguments to `train()` accordingly.**  

**The variable names and comments within the code chunks specify which model you are working with.**  

*NOTE*: The models are trained in separate code chunks that way you can run each model separately from the others.  

#### SOLUTION

```{r, solution_04d_01, eval=TRUE}
### model 1 addAll
set.seed(2021)
mod_1_acc <- train(y ~ .,
                       data = df,
                       method = "glm",
                       metric = metric_acc,
                       family = "binomial",
                       #preProcess = c("center", "scale"),
                       trControl = ctrl_acc)
mod_1_acc
```


```{r, solution_04d_02, eval=TRUE}
### model 2 allAll
set.seed(2021)
mod_2_acc <- train(y ~ . + I(x1^2) + I(x2^2) + I(x3^2) + I(x4^2),
                       data = df,
                       method = "glm",
                       metric = metric_acc,
                       family = "binomial",
                       preProcess = c("center", "scale"),
                       trControl = ctrl_acc)

mod_2_acc
```

```{r, solution_04d_03, eval=TRUE}
### model 3 1and2
set.seed(2021)
mod_3_acc <- train(y ~ . + I(x1^2) + I(x2^2),
                       data = df,
                       method = "glm",
                       metric = metric_acc,
                       family = "binomial",
                       preProcess = c("center", "scale"),
                       trControl = ctrl_acc)
mod_3_acc
```


```{r, solution_04d_04, eval=TRUE}
### model 4 1and3
set.seed(2021)
mod_4_acc <- train(y ~ . + I(x1^2) + I(x3^2),
                       data = df,
                       method = "glm",
                       metric = metric_acc,
                       family = "binomial",
                       preProcess = c("center", "scale"),
                       trControl = ctrl_acc)
mod_4_acc
```


```{r, solution_04d_05, eval=TRUE}
### model 5 1and4
set.seed(2021)
mod_5_acc <- train(y ~ . + I(x1^2) + I(x4^2),
                       data = df,
                       method = "glm",
                       metric = metric_acc,
                       family = "binomial",
                       preProcess = c("center", "scale"),
                       trControl = ctrl_acc)

mod_5_acc
```


```{r, solution_04d_06, eval=TRUE}
### model 6 2and3
set.seed(2021)
mod_6_acc <- train(y ~ . + I(x2^2) + I(x3^2),
                       data = df,
                       method = "glm",
                       metric = metric_acc,
                       family = "binomial",
                       preProcess = c("center", "scale"),
                       trControl = ctrl_acc)
mod_6_acc
```


```{r, solution_04d_07, eval=TRUE}
### model 7 2and4
set.seed(2021)
mod_7_acc <- train(y ~ . + I(x2^2) + I(x4^2),
                       data = df,
                       method = "glm",
                       metric = metric_acc,
                       family = "binomial",
                       preProcess = c("center", "scale"),
                       trControl = ctrl_acc)
mod_7_acc
```


```{r, solution_04d_08, eval=TRUE}
### model 8 3and4
set.seed(2021)
mod_8_acc <- train(y ~ . + I(x3^2) + I(x4^2),
                       data = df,
                       method = "glm",
                       metric = metric_acc,
                       family = "binomial",
                       preProcess = c("center", "scale"),
                       trControl = ctrl_acc)
mod_8_acc
```


### 4e)

You will now compile all resample results together and compare the models based on their Accuracy.  

**Complete the first code chunk below which assigns the models to the appropriate field within the `resamples()` function.**  

**Then use the `summary()` function to summarize the Accuracy across the resamples and visualize the resample averaged performance with the `dotplot()` function from `caret`. In the function calls to both `summary()` and `dotplot()`, set the `metric` argument equal to `'Accuracy'`.**  

**Which model is the best based on Accuracy? Are you confident it's the best?**  

*HINT*: The field names within the list contained in the `resamples()` call correspond to the model object you should use.  

#### SOLUTION

```{r, solution_04e_01, eval=TRUE}
acc_results <- resamples(list(mod_1 = mod_1_acc,
                              mod_2 = mod_2_acc,
                              mod_3 = mod_3_acc,
                              mod_4 = mod_4_acc,
                              mod_5 = mod_5_acc,
                              mod_6 = mod_6_acc,
                              mod_7 = mod_7_acc,
                              mod_8 = mod_8_acc))
```


Summarize the results across the resamples.  

```{r, solution_04e_02}
summary(acc_results, metric="Accuracy")
```


Visualize the resample averaged Accuracy per model.  

```{r, solution_04e_03}
dotplot(acc_results, metric = "Accuracy")
```


Which model is the best?  

Model 5 (linear features and quadratic features just inputs 1 and 4) has the highest accuracy.

### 4f)

Next, you will consider how a model was correct and how a model was wrong via the confusion matrix. You are allowed to use the `confusionMatrix()` function from the `caret` package in this assignment to create the confusion matrix. A `caret` model object can be passed as the argument to the `confusionMatrix()` function. The function will then calculate the average confusion matrix across all resample test-sets. The resulting confusion matrix is displayed with percentages instead of counts, as shown in the lecture slides. The interpretations however are the same.  

**Use the `confusionMatrix()` function to display the confusion matrix for the top two and worst two models according to Accuracy.**  

**How do the False-Positive and False-Negative behavior compare between these four models?**  

#### SOLUTION

Add as many code chunks as you feel are necessary.
Best: mod5, mod4
Worst: mod8, mod1

We can see below from the output of these code chonks that for the two models with the highest accuracy the percentage of false positives is unchanged, but the 2nd best model has a higher rate of false negatives. For the worst two models there seems to be the inverse of that going on. For the worst two models, the rate of false negatives is unchanged, but the worst model has a higher rate of false positives than the 2nd worst model.

```{r, 04f_solution_mod5}
# best
confusionMatrix(mod_5_acc)
```

```{r, 04f_solution_mod4}
# 2nd best
confusionMatrix(mod_4_acc)
```

```{r, 04f_solution_mod1}
# 2nd worst
confusionMatrix(mod_1_acc)
```

```{r, 04f_solution_mod8}
# worst
confusionMatrix(mod_8_acc)
```
## Problem 05

Now that you have compared the models based on Accuracy, it is time to consider another performance metric. The Accuracy is calculated using a single threshold value. You will now examine the model performance across all possible thresholds by studying the ROC curve.  

### 5a)

You will ultimately visually compare the ROC curves for the different models. Unfortunately with `caret`, we need to make several changes to the `trainControl()` function in order to support such comparisons. The code chunk below is started for you by including the necessary arguments you will need to visualize the ROC curves later.  

**You must complete the code chunk by specifying the same resampling scheme you used in Problem 4c). You must also specify the primary performance metric as `'ROC'`. That is how `caret` knows it must calculate the Area Under the Curve (AUC) for the ROC curve.**  

#### SOLUTION

```{r, solution_05a, eval=TRUE}
ctrl_roc <- trainControl(method = 'repeatedcv',
                         number = 5,
                         repeats = 5,
                         summaryFunction = twoClassSummary,
                         classProbs = TRUE,
                         savePredictions = TRUE)

metric_roc <- "ROC"
```

### 5b)

You will retrain the same set of 8 models that you trained in Problem 4d), but this time using the ROC AUC as the primary performance metric.  

**Complete the code chunks below so that you train the 8 models again, but this time focusing on the ROC AUC. The object name and comments within the code chunks specify the model you should use.**  

#### SOLUTION


```{r, solution_05b_01, eval=TRUE}
### model 1 addAll
set.seed(2021)
mod_1_roc <- train(y ~ . ,
                       data = df,
                       method = "glm",
                       metric = metric_roc,
                       family = "binomial",
                       preProcess = c("center", "scale"),
                       trControl = ctrl_roc)
mod_1_roc
```


```{r, solution_05b_02, eval=TRUE}
### model 2 allAll
set.seed(2021)
mod_2_roc <- train(y ~ . + I(x1^2) + I(x2^2) + I(x3^2) + I(x4^2),
                       data = df,
                       method = "glm",
                       metric = metric_roc,
                       family = "binomial",
                       preProcess = c("center", "scale"),
                       trControl = ctrl_roc)

mod_2_roc
```

```{r, solution_05b_03, eval=TRUE}
### model 3 1and2
set.seed(2021)
mod_3_roc <- train(y ~ . + I(x1^2) + I(x2^2),
                       data = df,
                       method = "glm",
                       metric = metric_roc,
                       family = "binomial",
                       preProcess = c("center", "scale"),
                       trControl = ctrl_roc)
mod_3_roc
```


```{r, solution_05b_04, eval=TRUE}
### model 4 1and3
set.seed(2021)
mod_4_roc <- train(y ~ . + I(x1^2) + I(x3^2),
                       data = df,
                       method = "glm",
                       metric = metric_roc,
                       family = "binomial",
                       preProcess = c("center", "scale"),
                       trControl = ctrl_roc)
mod_4_roc
```


```{r, solution_05b_05, eval=TRUE}
### model 5 1and4
set.seed(2021)
mod_5_roc <- train(y ~ . + I(x1^2) + I(x4^2),
                       data = df,
                       method = "glm",
                       metric = metric_roc,
                       family = "binomial",
                       preProcess = c("center", "scale"),
                       trControl = ctrl_roc)
mod_5_roc
```


```{r, solution_05b_06, eval=TRUE}
### model 6 2and3
set.seed(2021)
mod_6_roc <- train(y ~ . + I(x2^2) + I(x3^2),
                       data = df,
                       method = "glm",
                       metric = metric_roc,
                       family = "binomial",
                       preProcess = c("center", "scale"),
                       trControl = ctrl_roc)
mod_6_roc
```


```{r, solution_05b_07, eval=TRUE}
### model 7 2and4
set.seed(2021)
mod_7_roc <- train(y ~ . + I(x2^2) + I(x4^2),
                       data = df,
                       method = "glm",
                       metric = metric_roc,
                       family = "binomial",
                       preProcess = c("center", "scale"),
                       trControl = ctrl_roc)
mod_7_roc
```


```{r, solution_05b_08, eval=TRUE}
### model 8 3and4
set.seed(2021)
mod_8_roc <- train(y ~ . + I(x3^2) + I(x4^2),
                       data = df,
                       method = "glm",
                       metric = metric_roc,
                       family = "binomial",
                       preProcess = c("center", "scale"),
                       trControl = ctrl_roc)
mod_8_roc
```


### 5c)

You will now compile all resample results together and compare the models based on their area under the ROC curve.  

**Complete the first code chunk below which assigns the models to the appropriate field within the `resamples()` function.**  

**Then use the `summary()` function to summarize the ROC AUC across the resamples and visualize the resample averaged performance with the `dotplot()` function from `caret`. In the function calls to both `summary()` and `dotplot()`, set the `metric` argument equal to `'ROC'`.**  

**Which model is the best based on ROC AUC? Are you confident it's the best?**  

*HINT*: The field names within the list contained in the `resamples()` call correspond to the model object you should use.  

#### SOLUTION

```{r, solution_05c_01, eval=TRUE}
roc_results <- resamples(list(mod_1 = mod_1_roc,
                              mod_2 = mod_2_roc,
                              mod_3 = mod_3_roc,
                              mod_4 = mod_4_roc,
                              mod_5 = mod_5_roc,
                              mod_6 = mod_6_roc,
                              mod_7 = mod_7_roc,
                              mod_8 = mod_8_roc))
```


Summarize the results across the resamples.  

```{r, solution_05c_02}
summary(roc_results, metric="ROC")
```


Visualize the resample averaged ROC AUC per model.  

```{r, solution_05c_03}
dotplot(roc_results, metric="ROC")
```


Which model is the best?  

Model 3 is the best performing model of this set based on ROC.

### 5d)

By default, two other metrics are calculated by `caret` when we use the ROC AUC as the primary performance metric. Unlike ROC AUC, these two metrics are calculated with the default threshold. `caret` labels the the Sensitivity as the `Sens` metric and the Specificity as the `Spec` metric.  

**Use the `summary()` and `dotplot()` functions again, but do not specify a metric. Just provide the `roc_results` as the input argument to the functions.**  

**Which model has the highest True-Positive Rate at the default threshold? Which model has the lowest False-Positive Rate at the default threshold?**  

#### SOLUTION

Notes:
TPR = Sens
FPR = 1 - Spec
Thus, highest Spec = lowest FPR

Models:
Highest TPR = Model 5
Lowest FPR = Model 6

Add as many code chunks and as much text as you feel are necessary.  
```{r, solution_05d_01}
summary(roc_results)
```

```{r, solution_05d_02}
dotplot(roc_results)
```

### 5e)

In order to visualize the ROC curve we need to understand how the resample hold-out test predictions are stored within the `caret` model objects. By default, hold-out test set predictions are not retained, in order to conserve memory. However, the `ctrl_roc` object set `savePredictions = TRUE` which overrides the default behavior and stores each resample test-set predictions.  

The predictions are contained with the `$pred` field of the `caret` model object. The code chunk below displays the first few rows of the predictions for the `mod_1_roc` result for you. Note that the code chunk below is not evaluated by default. When you execute the code chunk below, you will see 7 columns. The column `obs` is the observed outcome and the column `event` is the predicted probability of the `event`. The `pred` column is the model classified outcome based on the default threshold of 50%. The `rowIndex` is the row from the original data set and serves to identify the row correctly. The `Resample` column tells us which resample fold the test point was associated with.  

```{r, show_results_2e, eval=TRUE}
mod_1_roc$pred %>% tibble::as_tibble()
```

The ROC curve is calculated by comparing the model predicted probability to all possible thresholds to create many different classifications. Those different classifications are used to calculate many different confusion matrices. Thus, the columns of primary interest in the prediction object displayed above are the `obs` and `event` columns.  

You manually created 3 points on the ROC curve previously in this assignment. Do NOT worry, you do NOT need to repeat those actions here! Instead you will use the `roc_curve()` function from the `yardstick` package to create the ROC curve data for you. The `roc_curve()` function has three primary arguments. The first is a data object which contains the predictions in a "tidy" format. The second is the name of the column that corresponds to the observed outcome (the truth or reference). The third is the name of the column in the data set that corresponds to the model predicted event probability.  

**Pipe the prediction data object for the `mod_1_roc` `caret` object to the `roc_curve()`. The `obs` column is the observed outcome and the `event` column is the model predicted event probability. Display the result to the screen to confirm the `roc_curve()` function worked. If it did the first few rows should correspond to very low threshold values.**  

**Why does the `sensitivity` have values at or near 1 when the `.threshold` is so low?**  

#### SOLUTION

```{r, solution_05e}
# roc_curve(tidy_predictions, observed outcome, predicted probability)
roc_curve(mod_1_roc$pred, obs, event)
```


What do you think?  

When the threshold is low, the model will identify everything or nearly everything as an event. Thus, both the TPR (Sensitivity) and the FPR (1 - Specificity) increase as the threshold decreases.

### 5f)

You will now visualize the ROC curve associated with `mod_1_roc`.  

**Repeat the same steps you performed in 5e) above, except pipe the result to the `autoplot()` method.**  

#### SOLUTION

```{r, solution_05f}
autoplot(roc_curve(mod_1_roc$pred, obs, event))
```


### 5g)

The ROC curve displayed in 5f) is the resample averaged ROC curve. You can examine the individual resample hold-out test set ROC curves by specifying a grouping structure with the `group_by()` function. This can help you get a sense of the variability in the ROC curve.  

**Pipe the prediction object associated with `mod_1_roc` to the `group_by()` function where you specify the grouping variable to be `Resample`. Pipe the result to `roc_curve()` where you specify the same arguments as in the previous questions. Finally, pipe the result to `autoplot()`.**  

#### SOLUTION

```{r, solution_05g}
mod_1_roc$pred %>%
  group_by(Resample) %>%  
  roc_curve(obs, event) %>%
  autoplot()
```


### 5h)

A function is defined for you in the code chunk below. This function compiles all model results together to enable comparing their ROC curves.  

```{r, make_roc_compile_function}
compile_all_model_preds <- function(m1, m2, m3, m4, m5, m6, m7, m8)
{
  purrr::map2_dfr(list(m1, m2, m3, m4, m5, m6, m7, m8),
                  as.character(seq_along(list(m1, m2, m3, m4, m5, m6, m7, m8))),
                  function(ll, lm){
                    ll$pred %>% tibble::as_tibble() %>% 
                      select(obs, event, Resample) %>% 
                      mutate(model_name = lm)
                  })
}
```


The code chunk below is also completed for you. It passes the `caret` model objects with the saved predictions to the `compile_all_model_preds()` function. The result is printed for you below so you can see the column names. Notice there is a new column `model_name` which stores the name of the model associated with the resample hold-out test set predictions. By default the code chunk below is not executed.  

```{r, run_compiile_all_model_preds, eval=TRUE}
all_model_preds <- compile_all_model_preds(mod_1_roc, mod_2_roc, mod_3_roc, 
                                           mod_4_roc, mod_5_roc,
                                           mod_6_roc, mod_7_roc, mod_8_roc)

all_model_preds
```

You will now create a figure which displays the resample averaged ROC curve for each model.  

**Pipe the `all_model_preds` object to `group_by()` and specify the grouping variable as `model_name`. Pipe the result to `roc_curve()` and specify the arguments accordingly. Pipe the result to `autoplot()` to generate the figure.**  

**Which model is the best? Is the result consistent with the ROC AUC summary metrics you calculated previously? Which model is closest to a "completely ineffective model" and why is that so?**  

#### SOLUTION

```{r, solution_05h}
all_model_preds %>%
  group_by(model_name) %>%
  roc_curve(obs, event) %>%
  autoplot()
```


What do you think?  

Even after popping out the graph to a new window I am having trouble identifying the colors as the legend is too small and I'm about at the age where I need reading glasses. Please be lenient with me here.

It looks like models 4 or 5 are the most "step-wise" of the set. Based on the means of ROC, Sens, and Spec, I am going to choose Model 5 as the best. It had the 3rd highest ROC, highest Sens, and right in the middle for Spec. Looking at all 8 models, Model 5 seems to be at or above average for all 3 metrics while the other models have shortcomings in at least one metric.

Visually, it looks like the most ineffective model seems to be Model 8, out of all the lines it looks the closest to a smooth curve without many "steps". Looking at the data from previous questions, Model 8 is at or below average on all 3 metrics.

## Problem 06

The performance metrics you have focused on up to this point are point-wise comparison metrics which evaluate the classification performance of a model. As discussed in lecture, binary classifier performance can also be measured based on the **calibration** between the predicted probability and the observed event proportion. The performance is represented graphically via the **calibration curve** which visualizes the correlation between the model predictions and the observed proportion of the event.  

Regardless of your rankings in the previous questions, you will compare the performance of model 1, model 3, and model 8 with the calibration curve. Although multiple functions exist to create the calibration curve, you **must** create the calibration curve manually in this problem. You are only allowed to use functions from the `dplyr` and `ggplot2` packages. You are **not** allowed to use any third party function to calculate the calibration curve in this problem.  

In the two previous problems, you used resampling to assess model performance. We could create the calibration curve based on the resample fold test sets, but we will instead start simpler and use a dedicated hold-out set that is different from the training data. The hold-out set is read in for you in the code chunk below.  

```{r, read_test_set}
test_data_path <- 'hw03_test_data.csv'

df_test <- readr::read_csv(test_data_path, col_names = TRUE)

df_test <- df_test %>% 
  mutate(y = factor(y, levels = c("event", "non_event")))
```


The code chunk below shows a glimpse of the test set, which demonstrates the test set has the same column names as the training set.  

```{r, show_test_set_glimpse}
df_test %>% glimpse()
```


### 6a)

The first step to create the calibration curve requires making predictions. The `predict()` function for a `caret` trained object function has two main arguments. The first is the model object we will use to make predictions with and the second, `newdata`, is the data set to predict. The input columns must have the same names as the inputs to the training data that trained the model.  

By default, a binary classifier will return the classifications assuming a 50% threshold. As discussed in lecture, the calibration curve does not work with classifications. Instead we need the predicted probability! We can override the default prediction behavior by setting additional arguments to the `predict()` function. Specifically, the `type` argument instructs the model to return a "type" of prediction. We want the predicted probability and so you must set `type = 'prob'` in the `predict()` function call.  

**Predict the hold-out test set using model 1 and assign the result to the variable `pred_test_1`. Return the predicted probability by setting the `type` argument to `'prob'`.**  

**Print the data type of the `pred_test_1` object to the screen and use the `head()` function to display the "top" of the object.**  

*HINT*: It does not matter whether you use the model 1 assessed based on Accuracy or ROC in this problem.  

#### SOLUTION

```{r, solution_06a}
### add more code chunks if you like
pred_test_1 <- predict(mod_1_roc, df_test, type = 'prob')
```

```{r, solution_06a_datatype}
print(typeof(pred_test_1))
```

```{r, solution_06a_head}
head(pred_test_1)
```

### 6b)

Your `pred_test_1` object should have 2 columns. The `event` column gives the predicted probability that `y == 'event'` and the `non_event` column stores the predicted probability that `y == 'non_event'`.  

**What is the relationship between the values in the `event` column and the `non_event` column?**  

#### SOLUTION

What do you think?  

The sum of event and non_event for every row will be equal to 1. This means there is a 100% chance that something either will or will not happen. It's probability.

### 6c)

The code chunk below binds the columns in `pred_test_1` with the `df_test` dataframe to create a new dataframe which includes the predicted probability of the event and the observed output, `y`, for the hold-out test set. **PLEASE NOTE**: the code chunk below is **NOT** evaluated by default. You must change the `eval` chunk option to make sure the code chunk is executed when you render the report.  

```{r, assemble_pred_mod1_obj, eval=TRUE}
test_df_1 <- df_test %>% bind_cols(pred_test_1)
```

As discussed in lecture, the calibration curve bins or lumps the predicted probability into uniformly spaced intervals. The empirical proportion of the event within each bin must be calculated. Thus, you need to convert the numeric predicted probability into a discrete or categorical variable.  

A simple, yet effective, approach for categorizing a continuous variable is the `cut()` function. The cut function is demonstrated in the code chunk below. The variable `x` is a column within a tibble (a dataframe). The `x` variable consists of integers between 0 and 100. The `x` variable is "cut" or divided into bins with **break points** at values of 0, 10, 20, 30, etc. The break points are created using the `seq()` function from 0 to 100 *by* increments of 10. The tibble is piped to the `count()` function to count the number of rows associated with each unique value of the `x_bin`. Pay close attention to the displayed values of `x_bin`. The values of `x_bin` show the "cut" or "divided" intervals. 

```{r, show_how_cut_works}
tibble::tibble(x = 0:100) %>% 
  mutate(x_bins = cut(x,
                      breaks = seq(0, 100, by = 10),
                      include.lowest = TRUE)) %>% 
  count(x_bins)
```


You must use the `cut()` function to bin the predicted probability associated with model 1 into 10 bins. Think carefully about how to specify the `breaks` argument to `cut()` so that the probability is divided into 10 uniform intervals.  

**Pipe `test_df_1` to `mutate()` and create a variable `pred_bin` by cutting the predicted probability into 10 uniform intervals. Assign the result to the `test_df_1_b` object.**  

*HINT*: You should not pipe the result to `count()` as the previous code chunk did. The `count()` function was used to show the *levels* of the created discrete variable.  

#### SOLUTION

```{r, solution_06c}
cut_tibble <- tibble::tibble(x = 1:120)

test_df_1_b <- test_df_1 %>% 
  mutate(pred_bin = cut(cut_tibble$x,
                      breaks = seq(0, 120, by = 12),
                      include.lowest = TRUE))
```


### 6d)

**Use the `count()` function to count the number of rows associated with each unique value of `pred_bin` in the `test_df_1_b` object. Display the result to the screen. How many unique values are displayed?**  

#### SOLUTION

```{r, solution_06d}
unique_pred_count <- test_df_1_b %>%
  count(pred_bin, y) %>%
  group_by(y)

unique_pred_count
# 18 unique! Yay!
```

18 unique

### 6e)

Show the counts per bin again but this time visualize the counts with a bar chart.  

**Create a bar chart with `ggplot2` for the counts associated with unique value of `pred_bin`.**  

#### SOLUTION

```{r, solution_06e}
test_df_1_b %>%
  ggplot(mapping = aes(x = pred_bin)) +
  geom_bar(mapping = aes(fill = y), position = 'dodge')
```

### 6f)

As shown in the lecture slides, we can create a stacked bar chart to get a rough idea about the number of events and non-events within each predicted probability bin. This is simple to do with `ggplot2` by using the `fill` aesthetic associated with the `geom_bar()` geometric object.  

**Create a stacked bar chart with `ggplot2` where the `fill` aesthetic is mapped to the observed binary outcome. Overrid the default fill color scheme by including the `scale_color_brewer()` function after the `geom_bar()` layer. Set the `palette` argument in `scale_color_brewer()` to `'Set1'`.**  

**Do any bins consist of only events? Do any bins consist of only non-events?**  

*HINT*: Which variable in the `test_df_1` tibble corresponds to the observed outcome?  

#### SOLUTION

What do you think?  

Yes, bin (12,24] contains only events. Bin (48,60] contains only non_events.

```{r, solution_06f}
test_df_1_b %>%
  ggplot(mapping = aes(x = pred_bin)) +
  geom_bar(mapping = aes(fill = y)) +
  scale_color_brewer(palette = 'Set1')
```


### 6g)

Instead of showing the counts within each bin, let's change the bar chart so the maximum height is 1. The stacked bar chart will therefore show the proportion of events and non-events within each predicted probability bin.  

**Recreate the stacked bar chart from the previous problem, but this time set the `position` argument to `'fill'` within the `geom_bar()` layer. The `position` argument should be specified outside the `aes()` function with `geom_bar()`. You must continue to map the `fill` aesthetic to the observed outcome.**  

**Are the empirical proptions of the event consistent with the predicted probability for model 1?**  

*HINT*: Pay close attention to the bar chart colors!  

#### SOLUTION

What do you think?  

Event proportions seem to be consistent!

```{r, solution_06g}
test_df_1_b %>%
  ggplot(mapping = aes(x = pred_bin)) +
  geom_bar(mapping = aes(fill = y), position = 'fill') +
  scale_color_brewer(palette = 'Set1')
```


## Problem 07

The bar chart visualized in Problem 06 is the calibration curve for model 1, but that is not how calibration curves are typically displayed. As shown in lecture, calibration curves are visualized as scatter plots with lines connecting the markers. The previous problem was used to demonstrate the proportion of the event per bin. In this problem, you will calculate the proportion of the event manually in each bin.  

This problem is open ended. You are free to calculate the event proportions however you want, as long as you do **NOT** use existing calibration curve functions. You are only allowed to use functions within `dplyr` and `ggplot2` in this problem.  

### 7a)

**Calculate the empirical proportion of events within each predicted probability bin associated with model 1. Although you are free to perform the calculations however you like, the results should be stored in a tibble (dataframe) named `my_calcurve_1` object. Your object should have columns for the `pred_bin`, the event proportion in the bin named `prop_event`, and the midpoint of the bin named `mid_bin`. Your `my_calcurve_1` object can have other columns, but those three columns are required.**  

#### SOLUTION

Add as many code chunks as you feel are necessary.

I've run out of time, I'm just cheesing this to get as much done as possible before midnight. Please forgive my horrible, horrible spaghetti... -Matt

```{r, 07a_solution_prop_event}
# prop_event calcs. each bin contains 12, so at least this is slightly easier to cheese... No events in the (48,60] bin. Unsure how to deal with that one calculating from the dataframe, so I did a dumb thing lol...

prop0_12 <- unique_pred_count[1,3] / 12
prop12_24 <- unique_pred_count[3,3] / 12
prop24_36 <- unique_pred_count[4,3] / 12
prop36_48 <- unique_pred_count[6,3] / 12
prop48_60 <- 1 - (unique_pred_count[8,3] / 12) #all non_events >_<
prop60_72 <- unique_pred_count[9,3] / 12
prop72_84 <- unique_pred_count[11,3] / 12
prop84_96 <- unique_pred_count[13,3] / 12
prop96_108 <- unique_pred_count[15,3] / 12
prop108_120 <- unique_pred_count[17,3] / 12

```

```{r, 07a_solution}
# making teh tibble...

my_calcurve_1 <- data.frame(pred_bin = unique(test_df_1_b$pred_bin),
                            prop_event = c(prop0_12[1,1], prop12_24[1,1], prop24_36[1,1], prop36_48[1,1], prop48_60[1,1], prop60_72[1,1], prop72_84[1,1], prop84_96[1,1], prop96_108[1,1], prop108_120[1,1]),
                            mid_bin = c(0.05, 0.15, 0.25, 0.35, 0.45, 0.55, 0.65, 0.75, 0.85, 0.95))

my_calcurve_1

```

### 7b)

You will now create the calibration curve associated with model 1's predictions on the hold-out test set! You must use the `my_calcurve_1` object created in Problem 7a).  

**Pipe the `my_calcurve_1` object to `ggplot()` and map `mid_bin` and `prop_event` to the `x` and `y` aesthetics, respectively. Include `geom_line()` and `geom_point()` layers and a `geom_abline()` layer. Set the `geom_abline()` arguments as `slope=1`, `intercept=0`, `color='grey'`, and `linetype='dashed'`. Include `coord_equal()` with `xlim = c(0,1)` and `ylim = c(0,1)`.**  

**Is the calibration curve consistent with your stacked filled barchart created previously? Pay close attention to the colors in the bar chart when comparing them!**  

#### SOLUTION

What do you think?  

Yes indeed, it looks like it is consistent with the stacked/filled barchart! But it does look kinda upside down, but still consistent.

```{r, solution_07b}
my_calcurve_1 %>%
  ggplot(mapping = aes(x = mid_bin, y = prop_event)) +
  geom_line() + 
  geom_point() +
  geom_abline(slope = 1, intercept = 0, color = 'grey', linetype = 'dashed') +
  coord_equal(xlim = c(0,1), ylim = c(0,1))
```


### 7c)

Now it's time to create the necessary objects associated with model 3 and model 8. As we started with model 1, we must predict the hold-out test set and return the predicted event probabilities.  

**Predict the hold-out test set using model 3 and model 8. Assign the results to the variables `pred_test_3` and `pred_test_8` for model 3 and model 8, respectively.**  

#### SOLUTION

```{r, solution_07c}
### model 3
pred_test_3 <- predict(mod_3_roc, df_test, type = 'prob')
head(pred_test_3)
```

```{r, solution_07c_mod8}
### model 8
pred_test_8 <- predict(mod_8_roc, df_test, type = 'prob')
head(pred_test_8)
```
### 7d)

The code chunk below is completed for you. The model 3 and model 8 predictions are combined with the hold-out test set data so you have the predicted probabilities and observed outcome within a tibble (dataframe). **PLEASE NOTE**: the code chunk below is **NOT** evaluated by default. You must change the `eval` chunk option to make sure the code chunk is executed when you render the report.  


```{r, make_test_dfs_for_3_8, eval=TRUE}
test_df_3 <- df_test %>% bind_cols(pred_test_3)

test_df_8 <- df_test %>% bind_cols(pred_test_8)
```


**You must create the categorical predicted probability bins for model 3 and model 8 using the `cut()` function. Assign the results to the `test_df_3_b` and `test_df_8_b` objects for model 3 and model 8, respectively.**  

#### SOLUTION

```{r, solution_04d}
### model 3
cut_tibble <- tibble::tibble(x = 1:120)
test_df_3_b <- test_df_3 %>% 
  mutate(pred_bin = cut(cut_tibble$x,
                      breaks = seq(0, 120, by = 12),
                      include.lowest = TRUE))
```

```{r, solution_04d_mod8}
### model 8
cut_tibble <- tibble::tibble(x = 1:120)
test_df_8_b <- test_df_8 %>% 
  mutate(pred_bin = cut(cut_tibble$x,
                      breaks = seq(0, 120, by = 12),
                      include.lowest = TRUE))
```

### 7e)

**Use `ggplot2` to visualize the number of observations per bin for model 3 with a bar chart.**  

#### SOLUTION

```{r, solution_07e}
test_df_3_b %>%
  ggplot(mapping = aes(x = pred_bin)) +
  geom_bar(mapping = aes(fill = y), position = 'dodge')
```

### 7f)

**Use `ggplot2` to visualize the number of observations per bin for model 8 with a bar chart.**  

#### SOLUTION

```{r, solution_07f}
test_df_8_b %>%
  ggplot(mapping = aes(x = pred_bin)) +
  geom_bar(mapping = aes(fill = y), position = 'dodge')
```


## Problem 08

Rather than using the stacked filled bar charts to represent the calibration curve for models 3 and 8, let's jump straight to creating the calibration curve object for the two models.  

### 8a)

**Calculate the empirical proportion of events within each predicted probability bin associated with model 3. Although you are free to perform the calculations however you like, the results should be stored in a tibble (dataframe) named `my_calcurve_3` object. Your object should have columns for the `pred_bin`, the event proportion in the bin named `prop_event`, and the midpoint of the bin named `mid_bin`. Your `my_calcurve_3` object can have other columns, but those three columns are required.**  

#### SOLUTION

```{r, solution_08a_count}
unique_pred_count_3 <- test_df_3_b %>%
  count(pred_bin, y) %>%
  group_by(y)

unique_pred_count_3
```

```{r, 08a_solution_prop_event}
# prop_event calcs.

prop0_12_3 <- unique_pred_count_3[1,3] / 12
prop12_24_3 <- unique_pred_count_3[3,3] / 12
prop24_36_3 <- unique_pred_count_3[4,3] / 12
prop36_48_3 <- unique_pred_count_3[6,3] / 12
prop48_60_3 <- 1 - (unique_pred_count_3[8,3] / 12) #all non_events >_<
prop60_72_3 <- unique_pred_count_3[9,3] / 12
prop72_84_3 <- unique_pred_count_3[11,3] / 12
prop84_96_3 <- unique_pred_count_3[13,3] / 12
prop96_108_3 <- unique_pred_count_3[15,3] / 12
prop108_120_3 <- unique_pred_count_3[17,3] / 12

```

```{r, 08a_solution}
# making teh tibble...

my_calcurve_3 <- data.frame(pred_bin = unique(test_df_3_b$pred_bin),
                            prop_event = c(prop0_12_3[1,1], prop12_24_3[1,1], prop24_36_3[1,1], prop36_48_3[1,1], prop48_60_3[1,1], prop60_72_3[1,1], prop72_84_3[1,1], prop84_96_3[1,1], prop96_108_3[1,1], prop108_120_3[1,1]),
                            mid_bin = c(0.05, 0.15, 0.25, 0.35, 0.45, 0.55, 0.65, 0.75, 0.85, 0.95))

my_calcurve_3

```  

### 8b)

**Calculate the empirical propotion of events within each predicted probability bin associated with model 8. Although you are free to perform the calculations however you like, the results should be stored in a tibble (dataframe) named `my_calcurve_8` object. Your object should have columns for the `pred_bin`, the event proportion in the bin named `prop_event`, and the midpoint of the bin named `mid_bin`. Your `my_calcurve_8` object can have other columns, but those three columns are required.**  

#### SOLUTION

Add as many code chunks as you feel are necessary.  
```{r, solution_08b_count}
unique_pred_count_8 <- test_df_8_b %>%
  count(pred_bin, y) %>%
  group_by(y)

unique_pred_count_8
```

```{r, 08b_solution_prop_event}
# prop_event calcs.

prop0_12_8 <- unique_pred_count_8[1,3] / 12
prop12_24_8 <- unique_pred_count_8[3,3] / 12
prop24_36_8 <- unique_pred_count_8[4,3] / 12
prop36_48_8 <- unique_pred_count_8[6,3] / 12
prop48_60_8 <- 1 - (unique_pred_count_8[8,3] / 12) #all non_events >_<
prop60_72_8 <- unique_pred_count_8[9,3] / 12
prop72_84_8 <- unique_pred_count_8[11,3] / 12
prop84_96_8 <- unique_pred_count_8[13,3] / 12
prop96_108_8 <- unique_pred_count_8[15,3] / 12
prop108_120_8 <- unique_pred_count_8[17,3] / 12

```

```{r, 08b_solution}
# making teh tibble...

my_calcurve_8 <- data.frame(pred_bin = unique(test_df_8_b$pred_bin),
                            prop_event = c(prop0_12_8[1,1], prop12_24_8[1,1], prop24_36_8[1,1], prop36_48_8[1,1], prop48_60_8[1,1], prop60_72_8[1,1], prop72_84_8[1,1], prop84_96_8[1,1], prop96_108_8[1,1], prop108_120_8[1,1]),
                            mid_bin = c(0.05, 0.15, 0.25, 0.35, 0.45, 0.55, 0.65, 0.75, 0.85, 0.95))

my_calcurve_8

```  


### 8c)

**Visualize the calibration curve for model 3 using the approach described in Problem 7b).**  

#### SOLUTION

```{r, solution_08c}
my_calcurve_3 %>%
  ggplot(mapping = aes(x = mid_bin, y = prop_event)) +
  geom_line() + 
  geom_point() +
  geom_abline(slope = 1, intercept = 0, color = 'grey', linetype = 'dashed') +
  coord_equal(xlim = c(0,1), ylim = c(0,1))
```

### 8d)

**Visualize the calibration curve for model 8 using the approach described in Problem 7b).**  

#### SOLUTION

```{r, solution_08d}
my_calcurve_3 %>%
  ggplot(mapping = aes(x = mid_bin, y = prop_event)) +
  geom_line() + 
  geom_point() +
  geom_abline(slope = 1, intercept = 0, color = 'grey', linetype = 'dashed') +
  coord_equal(xlim = c(0,1), ylim = c(0,1))
```

### 8d)

**Based on your calibration curves, which of the three models appears the most well calibrated? Is it easy obvious which model performs better using this approach? What are the most obvious aspects of performance based on your calibration curves?**  

#### SOLUTION

What do you think?  

So the probabilities for event/non_event are all different in test_df_1,3,8. But I've clearly done something wrong. All 3 models have the exact same proportions (should be number of events divided by total observations in a bin?), and thus, calibration curves... Oh well, maybe this will be obvious after Problem 9, maybe not. I have about 3 hours left to submit at this time. Will come back IF POSSIBLE...


## Problem 09

Calibration curves are created by executing many tedious steps. Although you had to perform those steps manually in this assignment there are existing functions which perform the necessary calculations for you. One such function is the `caret::calibration()` function. You will use that function in this problem to practice easily creating calibration curves. The `caret::calibration()` function works with resampled results, but for consistency with the previous problems, we will use with the hold-out test set predictions associated with the `df_test` data set.  

The `caret::calibration()` function has 3 main arguments. The first argument is a formula, the second argument is the data set, and third is the number of bins to use. The formula follows a specific pattern:  

`<binary output variable> ~ <event probability variable>`  

The formula therefore gives the binary outcome variable name to the **left** of the tilde and the variable name for the event probability to the **right** of the tilde. These names **must** match the column names in the data set assigned to the `data` argument. The number of bins is specified by the `cuts` argument.  

### 9a)

**Create the calibration curve associated with model 1's hold-out test predictions using the `caret::calibration()` function. Specify the formula to be consistent with the `test_df_1` data set. Assign the `test_df_1` object to the `data` argument and assign `cuts = 10`. Pipe the result to the `xyplot()` function.**  

**Is the created calibration curve consistent with your manually created curve from the previous problems?**  

#### SOLUTION

Not even close to consistent. I will have to go back to the manual calibration curve if possible. I clearly did something wrong.

```{r, solution_09a}
# y ~ event
caret::calibration(y ~ event, data = test_df_1, cuts = 10) %>%
  xyplot()
```


### 9b)

**Create the calibration curve associated with model 3's hold-out test predictions using the `caret::calibration()` function. Specify the formula to be consistent with the `test_df_3` data set. Assign the `test_df_3` object to the `data` argument and assign `cuts = 10`. Pipe the result to the `xyplot()` function.**  

**Is the created calibration curve consistent with your manually created curve from the previous problems?**  

#### SOLUTION

Not even close to consistent. I will have to go back to the manual calibration curve if possible. I clearly did something wrong.

```{r, solution_09b}
caret::calibration(y ~ event, data = test_df_3, cuts = 10) %>%
  xyplot()
```


### 9c)

**Create the calibration curve associated with model 8's hold-out test predictions using the `caret::calibration()` function. Specify the formula to be consistent with the `test_df_8` data set. Assign the `test_df_8` object to the `data` argument and assign `cuts = 10`. Pipe the result to the `xyplot()` function.**  

**Is the created calibration curve consistent with your manually created curve from the previous problems?**  

#### SOLUTION

Not even close to consistent. I will have to go back to the manual calibration curve if possible. I clearly did something wrong.

```{r, solution_09c}
caret::calibration(y ~ event, data = test_df_8, cuts = 10) %>%
  xyplot()
```



